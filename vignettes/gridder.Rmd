---
title: "GridDER: Grid Detection and Evaluation in R"
author: "Feng et al. 2022"
date: "`r format(Sys.time(), '%d %B %Y')`"
output:
    rmarkdown::html_vignette:
        toc: true
        number_sections: true
    md_document:
      variant: gfm
vignette: >
  %\VignetteEncoding{UTF-8}
  %\VignetteIndexEntry{GridDER: Grid Detection and Evaluation in R}
  %\VignetteEngine{knitr::rmarkdown}
    \usepackage[utf8]{inputenc}
---


```{r setup, include=FALSE}
knitr::opts_chunk$set(echo = TRUE) # for development
```

```{r load, echo = FALSE, eval = TRUE, include=FALSE}
devtools::load_all() # for development
```


<br/><br/>

# Introduction

The package is a tool for identifying biodiversity records that have been designated locations on widely used grid systems. Our tool also estimates the degree of environmental heterogeneity associated with grid systems, allowing users to make informed decisions about how to use such occurrence data in global change studies. We show that a significant proportion (~13.5%; 261 million) of records on GBIF, largest aggregator of natural history collection data, are potentially gridded data, and demonstrate that our tool can reliably identify such records and quantify the associated uncertainties.

## Main features and workflow

```{r workflow image, out.width="80%"}
knitr::include_graphics("inst/workflow.png")
```

## Grid systems  examples 

Examples of four grid systems used in France (a), United Kingdom (b), South Africa
(c), and Australia (d). The four grid systems have different spatial solutions â€“ 10km for (a), 1km
for (b), 5 arc-minute for (c), and 6 arc-minute for (d). The black points represent the biological
collections assigned to the centroid of the corresponding grid systems. All maps constructed
using WGS84.

```{r grid_systems, out.width="80%"}
knitr::include_graphics("inst/fig_1_temp.png")
```


# Funtions

## Case 1: Infer the metadata of a grid system

### 1.1 Infer coordinate reference system - We use 4 core. Please certify that you have at least 4 cores available.  

```{r infer_crs}

data("occs_unique")# dataframe of occurrences

results_crs = gridder::infer_crs(occ_path = occs_unique,
                                  truth_crs_num = "2154", 
                                  cup_num = 4)
```

### 1.2  Infer the spatial resolution

```{r infer_resolution}
data("occs_unique")# dataframe of occurrences

input_occ = gridder::load_occ(occs_unique)
input_occ_prj = sp::spTransform(input_occ,crs(paste0("+init=epsg:","2154")))
result_res = gridder::infer_resolution(input_coord=input_occ_prj@coords,flag_unit="meter")
print(result_res$res_x)
print(result_res$res_y)

```

### 1.3  Infer the spatial exten

```{r infer_extent}
result_ext = gridder::infer_extent(method="crs_extent",
                          crs_grid=results_crs$selected$code[1],
                          flag_adjust_by_res=TRUE,
                          res_x=result_res$res_x,
                          res_y=result_res$res_y)

result_ext
```


## Case 2 Generation of a grid system based on metadata

```{r grid_generation}

simulated_grid = gridder::grid_generation(res_x=result_res$res_x,
                                          res_y=result_res$res_y,
                                          unit="m",
                                          flag_crs=TRUE,
                                          country="France",
                                          extent_unit="empirical_occ_extent",
                                          input_extent=result_ext,
                                          flag_offset=c(0,-result_res$res_y*10,
                                                        result_res$res_x*10,0),
                                          crs_num=results_crs$selected$code[1],
                                          flag_maskByCountry=TRUE)

```


## Case3: Match occ data set against known grid systems

```{r grid_matching}
point_grid = input_occ[sample(1:length(input_occ),100),]
point_nongrid = point_grid
point_nongrid@coords=point_nongrid@coords+runif(100)
point_all=rbind(point_grid,point_nongrid)

grid_metadata = data.frame(grid_ID=c("88"),
                           resolution_x=c(10000),
                           resolution_y=c(10000),
                           resolution_unit=c("m"))

temp_result = gridder::grid_matching(input_occ=point_all,
                                     input_grid=simulated_grid,
                                     grid_metadata=grid_metadata,
                                     flag_relativeTHD=0.1,
                                     flag_absoluteTHD=10)

table(temp_result@data$grid_closest_both)
```
## Case 4: Compute variation of environmental conditions

As the package uses rgee (R package to acessess Google Earth Engine API), the following commands must be executed:


#### Installation and presetting steps

Requirements 
_Phyton > 3.5 
-Earth ENgine account and credentials

As the package uses rgee (R package to acessess Google Earth Engine API), the following commands must be executed:

##### Create virtual environmental to install the necessary dependencies

```{r venv, echo=TRUE, eval=FALSE}
rgee::ee_install()
```

If the following message happen :
`An error occur when ee_install was creating the Python Environment. Run ee_clean_pyenv() and restart the R session, before trying again`

Then execute the bellow command and restart R session:

```{r ee_clean_pyenv, echo=TRUE, eval=FALSE}
rgee::ee_clean_pyenv()
```

After that you must run Step 1

Tou will resuest to continues and Rstart R seccion choose Yes in both cases 


##### Initialize

The follow command authorizes rgee to manage Earth Engine resources

```{r initialize, echo=TRUE, eval=FALSE}
rgee::ee_Initialize()
```
##### Check

```{r ee_check, echo=TRUE, eval=FALSE}
rgee::ee_check()
```

## assess_env_uncertainty 

##### Load ImageCollection of interest (environmental layer)

```{r add image, echo=TRUE, eval=TRUE}

rgee::ee_Initialize()
nasadem<- rgee::ee$Image('NASA/NASADEM_HGT/001')$select('elevation')
```

##### Create hypothetical grid system

```{r grid, echo=TRUE, eval= TRUE}
lat_lon_grid <- structure(list(ID = 758432:758443,
                              lat = c(-14.875, -14.875, -14.625, -14.625, -14.875, -14.875, -14.625, -14.625, -14.375, -14.375, -14.125, -14.125),
                              lon = c(-42.875, -42.625, -42.625, -42.875, -42.375, -42.125, -42.125, -42.375, -42.375, -42.125, -42.125, -42.375)),
                         class = "data.frame", row.names = c(NA, -12L))

grid_to_raster <- raster::rasterFromXYZ(lat_lon_grid [, c('lon', 'lat', 'ID')], crs = '+proj=longlat +datum=WGS84 +no_defs')

grid <- raster::rasterToPolygons(grid_to_raster, fun=NULL, na.rm=TRUE, dissolve=FALSE) |>
 sf::st_as_sf() |>
 rgee::sf_as_ee()

```

#### Plot 
The hypothetical grid is located in Brazil. Use zoom in tool to view. 

```{r plot, echo=TRUE, eval=TRUE, results='asis', out.width= "100%"}
rgee::Map$addLayer(grid)
```

#### Compute standard deviation
```{r, std_dev, echo=TRUE, eval=TRUE}
std_dev <- gridder::assess_env_uncertainty(x= nasadem, y= grid)

knitr::kable(std_dev)
```
 
