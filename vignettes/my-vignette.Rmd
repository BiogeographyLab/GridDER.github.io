---
title: "GridDER: Grid Detection and Evaluation in R"
author: "Feng et al. 2022"
date: "`r format(Sys.time(), '%d %B %Y')`"
output:
    rmarkdown::html_vignette:
        toc: true
        number_sections: true
    md_document:
      variant: gfm
vignette: >
  %\VignetteEncoding{UTF-8}
  %\VignetteIndexEntry{GridDER: Grid Detection and Evaluation in R}
  %\VignetteEngine{knitr::rmarkdown}
    \usepackage[utf8]{inputenc}
---


```{r setup, include=FALSE}
knitr::opts_chunk$set(echo = TRUE) # for development
```

```{r load, echo = FALSE, eval = TRUE, include=FALSE}
devtools::load_all() # for development
```


<br/><br/>

## Introduction

The package is a tool for identifying biodiversity records that have been designated locations on widely used grid systems. Our tool also estimates the degree of environmental heterogeneity associated with grid systems, allowing users to make informed decisions about how to use such occurrence data in global change studies. We show that a significant proportion (~13.5%; 261 million) of records on GBIF, largest aggregator of natural history collection data, are potentially gridded data, and demonstrate that our tool can reliably identify such records and quantify the associated uncertainties.

## Main features and workflow


```{r workflow image, echo=FALSE, out.width="80%"}
knitr::include_graphics("inst/workflow.png")
```
## List of functions 
```{r table_2, echo=FALSE}
table_2 <- readr::read_csv("inst/table_2.csv")
knitr::kable(table_2)
```
## Metada 
A metadata sheet with all grid systems compiled
```{r metadata}
meta_data <- gsheet::gsheet2tbl("https://docs.google.com/spreadsheets/d/1Qp5KOpLSVnF2t16uIbNwKwK5ZBXt4k5unONp7eopPzI/edit#gid=166945453") |> 
  as_tibble()

meta_data

```
## Grid systems  examples 

Examples of four grid systems used in France (a), United Kingdom (b), South Africa
(c), and Australia (d). The four grid systems have different spatial solutions â€“ 10km for (a), 1km
for (b), 5 arc-minute for (c), and 6 arc-minute for (d). The black points represent the biological
collections assigned to the centroid of the corresponding grid systems. All maps constructed
using WGS84.

```{r grid_systems, echo=FALSE, out.width="80%"}
knitr::include_graphics("inst/fig1.png")
```


## Funtions

### Infer coordinate reference system 

First load the demo occurrence data. This dataset includes a group of gridded coordinates, it was originally downloaded from GBIF, and has been simplified to be spatially unique for easier demonstration.


```{r plot map and occs}
library(ggplot2)
library(broom)

data("occs_unique") # dataframe of occurrences
data("ne_10m_admin_0_countries") # orld map

spdf_fortified <- broom::tidy(ne_10m_admin_0_countries, region = "ADMIN")

ggplot2::ggplot() +
  geom_polygon(data = spdf_fortified, 
               aes( x = long, y = lat, group = group), 
               fill="#69b3a2", color="white") +
  geom_point(data = occs_unique,
             aes(x = decimalLongitude, y = decimalLatitude), 
             size = 2, 
        shape = 23, fill = "darkred") +
    coord_sf(xlim = c(-10, 20), ylim = c(40, 60), expand = FALSE)

```
<br>
The coordinates have been projected to WGS84, which could be different from the CRS where the grid system was defined. So here we use infer_crs() to infer the correct CRS.

```{r infer_crs}
results_crs = gridder::infer_crs(occ_path = occs_unique, # input of coordinates
                                  truth_crs_num = "2154", # here we know the true CRS, just add it here for a comparison with the inferred CRS 
                                  cup_num = 4)# the function will loop through many CRS, so using multiple cores can speed up the process. The default uses 4 cores, thus certify at least 4 cores are available.

# Now, let's take a look at the output.

#head(results_crs, n=10)
```


### Infer the spatial resolution

```{r infer_resolution}
data("occs_unique")# dataframe of occurrences

input_occ = gridder::load_occ(occs_unique)
input_occ_prj = sp::spTransform(input_occ,crs(paste0("+init=epsg:","2154")))
result_res = gridder::infer_resolution(input_coord=input_occ_prj@coords,flag_unit="meter")
print(result_res$res_x)
print(result_res$res_y)

```

### Infer the spatial exten

```{r infer_extent}
result_ext = gridder::infer_extent(method="crs_extent",
                          crs_grid=results_crs$selected$code[1],
                          flag_adjust_by_res=TRUE,
                          res_x=result_res$res_x,
                          res_y=result_res$res_y)

result_ext
```


### Generation of a grid system based on metadata

```{r grid_generation}

simulated_grid = gridder::grid_generation(res_x=result_res$res_x,
                                          res_y=result_res$res_y,
                                          unit="m",
                                          flag_crs=TRUE,
                                          country="France",
                                          extent_unit="empirical_occ_extent",
                                          input_extent=result_ext,
                                          flag_offset=c(0,-result_res$res_y*10,
                                                        result_res$res_x*10,0),
                                          crs_num=results_crs$selected$code[1],
                                          flag_maskByCountry=TRUE)

```


### Match occ data set against known grid systems

```{r grid_matching}
point_grid = input_occ[sample(1:length(input_occ),100),]
point_nongrid = point_grid
point_nongrid@coords=point_nongrid@coords+runif(100)
point_all=rbind(point_grid,point_nongrid)

grid_metadata = data.frame(grid_ID=c("88"),
                           resolution_x=c(10000),
                           resolution_y=c(10000),
                           resolution_unit=c("m"))

temp_result = gridder::grid_matching(input_occ=point_all,
                                     input_grid=simulated_grid,
                                     grid_metadata=grid_metadata,
                                     flag_relativeTHD=0.1,
                                     flag_absoluteTHD=10)

table(temp_result@data$grid_closest_both)
```


Installation and presetting steps

Requirements 
- Phyton > 3.5 
<br>
- Earth Engine account and credentials
<br>

As the package uses rgee (R package to acessess Google Earth Engine API), the following commands must be executed:


```{r setting intalations, echo=TRUE, eval=FALSE}

rgee::ee_install() # Creating virtual environmental to install the necessary dependencies

# If the following message happen : `An error occur when ee_install was creating the Python Environment. Run ee_clean_pyenv() and restart the R session, before trying again`

# Then execute the bellow command and restart R session:

rgee::ee_clean_pyenv()

# After that you must run `rgee::ee_install()`. You will request to continues and Rstart R seccion choose Yes in all options.

rgee::ee_Initialize() # The follow command authorizes rgee to manage Earth Engine resources

rgee::ee_check() # Checks if everything is OK. Optinal command . 


```


### Compute variation of environmental conditions

```{r add image, echo=TRUE, eval=TRUE}
rgee::ee_Initialize()

# Load ImageCollection of interest (environmental layer)

nasadem = rgee::ee$Image('NASA/NASADEM_HGT/001')$select('elevation') # Global elevation data in 30 meters. We do not plot due to extension and resolution 

# Few squares represent a grid system for demonstration
lat_lon_grid <- structure(list(ID = 758432:758443,
                              lat = c(-14.875, -14.875, -14.625, -14.625, -14.875, -14.875, -14.625, -14.625, -14.375, -14.375, -14.125, -14.125),
                              lon = c(-42.875, -42.625, -42.625, -42.875, -42.375, -42.125, -42.125, -42.375, -42.375, -42.125, -42.125, -42.375)),
                         class = "data.frame", row.names = c(NA, -12L))

grid_to_raster <- raster::rasterFromXYZ(lat_lon_grid [, c('lon', 'lat', 'ID')], crs = '+proj=longlat +datum=WGS84 +no_defs')

grid <- raster::rasterToPolygons(grid_to_raster, fun=NULL, na.rm=TRUE, dissolve=FALSE) |>
 sf::st_as_sf() |> 
 rgee::sf_as_ee()

# Plot
rgee::Map$centerObject(grid, zoom = 7)
rgee::Map$addLayer(grid) 

# Compute standard deviation

std_dev <- gridder::assess_env_uncertainty(x= nasadem, y= grid)

knitr::kable(std_dev)

```

